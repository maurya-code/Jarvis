<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ABHISHEK MAURYA | NEURAL LINK v10.0</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Share Tech Mono', monospace; color: #00FF41; }
        #input_video { position: absolute; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 1; filter: brightness(0.65) contrast(1.1); }
        #three_canvas { position: absolute; top: 0; left: 0; z-index: 10; pointer-events: none; }
        #biometric_canvas { position: absolute; width: 100vw; height: 100vh; z-index: 15; transform: scaleX(-1); pointer-events: none; }

        /* HUD Panels */
        .hud-panel { position: absolute; z-index: 100; background: rgba(0, 20, 0, 0.5); border: 1px solid rgba(0, 255, 65, 0.4); backdrop-filter: blur(8px); padding: 15px; box-shadow: 0 0 15px rgba(0,255,65,0.2); }
        #top-left { top: 25px; left: 25px; border-left: 4px solid #00FF41; width: 280px; }
        #bottom-right { bottom: 25px; right: 25px; text-align: right; }
        #bottom-left { bottom: 25px; left: 25px; font-size: 10px; max-height: 120px; overflow: hidden; opacity: 0.8; width: 300px; }
        
        .mode-indicator { font-size: 18px; font-weight: bold; letter-spacing: 2px; text-transform: uppercase; margin-top: 5px; }
        #start-overlay { position: fixed; inset: 0; background: #000; z-index: 1000; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .btn-launch { padding: 15px 50px; background: transparent; border: 2px solid #00FF41; color: #00FF41; font-family: inherit; cursor: pointer; letter-spacing: 5px; transition: 0.3s; }
        .btn-launch:hover { background: #00FF41; color: #000; box-shadow: 0 0 30px #00FF41; }
    </style>
</head>
<body>

    <div id="start-overlay">
        <div style="font-size: 10px; margin-bottom: 20px; letter-spacing: 8px;">SYMMETRIC_NEURAL_V10</div>
        <button class="btn-launch" onclick="engage()">ENGAGE_SYSTEM</button>
    </div>

    <video id="input_video" autoplay playsinline muted></video>
    
    <div id="top-left" class="hud-panel">
        <div style="font-size: 12px; opacity: 0.7;">LINK_IDENT: ABHISHEK MAURYA</div>
        <div id="mode-text" class="mode-indicator">SYSTEM_IDLE</div>
        <div style="margin-top: 10px; font-size: 10px;">SCALE_FACTOR: <span id="scale-val">1.00</span>x</div>
    </div>

    <div id="bottom-left" class="hud-panel">
        <div id="kernel-logs">> SYSTEM_BOOT_SUCCESS<br>> NEURAL_MAPPING_ON<br>> READY_FOR_SPATIAL_INPUT</div>
    </div>

    <div id="bottom-right" class="hud-panel">
        <div>VOXEL_LOAD: <span id="count">000</span></div>
        <div style="font-size: 10px; color: #ff3333;">[ DUAL_FIST_TO_PURGE ]</div>
    </div>

    <canvas id="three_canvas"></canvas>
    <canvas id="biometric_canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('input_video');
        const bioCanvas = document.getElementById('biometric_canvas');
        const bioCtx = bioCanvas.getContext('2d');
        const logBox = document.getElementById('kernel-logs');

        // --- ENGINE SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three_canvas'), antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const worldGroup = new THREE.Group();
        scene.add(worldGroup);
        const voxelGroup = new THREE.Group();
        worldGroup.add(voxelGroup);
        camera.position.z = 30;

        const crosshair = new THREE.Mesh(new THREE.RingGeometry(0.5, 0.6, 32), new THREE.MeshBasicMaterial({ color: 0x00FF41, transparent: true, opacity: 0.6 }));
        scene.add(crosshair);

        // State Tracking
        let sL = Array(21).fill({x:0,y:0}), sR = Array(21).fill({x:0,y:0}); // Smoothed Hands
        let isGrabbing = false, grabOffset = new THREE.Vector3();
        let currentScale = 1.0, initialHandDist = 0;
        let placedVoxels = new Map();
        let purgeTimer = 0;

        function log(txt) {
            logBox.innerHTML += `<br>> ${txt}`;
            if(logBox.innerHTML.split('<br>').length > 6) logBox.innerHTML = logBox.innerHTML.split('<br>').slice(1).join('<br>');
        }

        function speak(text) {
            const utter = new SpeechSynthesisUtterance(text);
            utter.pitch = 0.6; utter.rate = 1.1;
            window.speechSynthesis.speak(utter);
        }

        async function engage() {
            document.getElementById('start-overlay').style.display = 'none';
            speak("Interface initialized. Welcome, Abhishek.");
            
            const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.85, minTrackingConfidence: 0.85 });
            hands.onResults(onResults);

            new Camera(videoElement, {
                onFrame: async () => {
                    bioCanvas.width = videoElement.videoWidth;
                    bioCanvas.height = videoElement.videoHeight;
                    await hands.send({image: videoElement});
                }
            }).start();
            animate();
        }

        function onResults(results) {
            bioCtx.clearRect(0, 0, bioCanvas.width, bioCanvas.height);
            crosshair.visible = false;
            if (!results.multiHandLandmarks) return;

            let hL = null, hR = null;
            results.multiHandedness.forEach((hand, idx) => {
                const raw = results.multiHandLandmarks[idx];
                const smooth = hand.label === 'Left' ? sL : sR;
                raw.forEach((pt, i) => {
                    smooth[i] = { x: smooth[i].x + (pt.x - smooth[i].x)*0.3, y: smooth[i].y + (pt.y - smooth[i].y)*0.3 };
                });
                drawTechnicalHand(bioCtx, smooth);
                if(hand.label === 'Left') hL = smooth;
                if(hand.label === 'Right') hR = smooth;
            });

            // --- 1. DUAL FIST PURGE ---
            if (hL && hR && hL[8].y > hL[6].y && hR[8].y > hR[6].y) {
                purgeTimer++;
                bioCtx.strokeStyle = "#ff3333"; bioCtx.lineWidth = 10;
                bioCtx.strokeRect(0,0, bioCanvas.width, bioCanvas.height);
                if(purgeTimer > 50) {
                    voxelGroup.children.slice().forEach(c => voxelGroup.remove(c));
                    placedVoxels.clear(); log("MEMORY_WIPED"); speak("Cleared.");
                    purgeTimer = 0; document.getElementById('count').innerText = "000";
                }
                return;
            } else { purgeTimer = 0; }

            // --- 2. DUAL OPEN HAND (SCALING) ---
            if (hL && hR && hL[8].y < hL[6].y && hR[8].y < hR[6].y && !isGrabbing) {
                const currentDist = Math.sqrt(Math.pow(hL[9].x - hR[9].x, 2) + Math.pow(hL[9].y - hR[9].y, 2));
                if (initialHandDist === 0) initialHandDist = currentDist;
                
                const scaleDelta = (currentDist / initialHandDist);
                voxelGroup.scale.set(scaleDelta, scaleDelta, scaleDelta);
                
                document.getElementById('mode-text').innerText = "RESIZE_ACTIVE";
                document.getElementById('scale-val').innerText = scaleDelta.toFixed(2);
                return;
            } else { initialHandDist = 0; }

            // --- 3. GRAB & MOVE (Left Hand Fist) ---
            if (hL) {
                const isFist = hL[8].y > hL[6].y;
                const handWorld = new THREE.Vector3((0.5 - hL[9].x) * 40, (0.5 - hL[9].y) * 22, 0);
                if (isFist) {
                    if (!isGrabbing) {
                        isGrabbing = true;
                        grabOffset.copy(worldGroup.position).sub(handWorld);
                        log("OBJ_LOCK_ENGAGED");
                    }
                    worldGroup.position.copy(handWorld).add(grabOffset);
                    document.getElementById('mode-text').innerText = "MOVING_OBJ";
                } else { isGrabbing = false; }
            }

            // --- 4. PRECISION BUILD (Right Hand Pinch) ---
            if (hR) {
                const thumb = hR[4], index = hR[8];
                const pinch = Math.sqrt(Math.pow(thumb.x-index.x,2)+Math.pow(thumb.y-index.y,2)) < 0.035;
                const bPos = new THREE.Vector3((0.5 - index.x) * 40, (0.5 - index.y) * 22, 0);
                const local = voxelGroup.worldToLocal(bPos.clone());
                const gx = Math.round(local.x / 1.2) * 1.2;
                const gy = Math.round(local.y / 1.2) * 1.2;
                const gz = Math.round(local.z / 1.2) * 1.2;

                if (pinch && !isGrabbing) {
                    const key = `${gx.toFixed(1)},${gy.toFixed(1)},${gz.toFixed(1)}`;
                    if (!placedVoxels.has(key)) {
                        const cube = create2050Cube(gx, gy, gz);
                        voxelGroup.add(cube);
                        placedVoxels.set(key, cube);
                        log(`DATA_WRITTEN: ${key}`);
                        document.getElementById('count').innerText = placedVoxels.size.toString().padStart(3, '0');
                    }
                }
                crosshair.visible = true;
                crosshair.position.copy(voxelGroup.localToWorld(new THREE.Vector3(gx, gy, gz)));
                if(!isGrabbing) document.getElementById('mode-text').innerText = "ARCHITECT_MODE";
            }
        }

        function create2050Cube(x, y, z) {
            const g = new THREE.BoxGeometry(1.1, 1.1, 1.1);
            const m = new THREE.MeshPhongMaterial({ color: 0x001100, emissive: 0x00FF41, emissiveIntensity: 0.8, transparent: true, opacity: 0.8 });
            const mesh = new THREE.Mesh(g, m);
            mesh.position.set(x, y, z);
            mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({ color: 0x00FF41 })));
            return mesh;
        }

        function drawTechnicalHand(ctx, pts) {
            ctx.strokeStyle = "rgba(0, 255, 65, 0.4)"; ctx.lineWidth = 1;
            ctx.beginPath();
            const CONNS = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,9],[9,13],[13,17],[0,17],[5,6],[6,7],[7,8],[9,10],[10,11],[11,12],[13,14],[14,15],[15,16],[17,18],[18,19],[19,20]];
            CONNS.forEach(([a, b]) => {
                ctx.moveTo(pts[a].x * bioCanvas.width, pts[a].y * bioCanvas.height);
                ctx.lineTo(pts[b].x * bioCanvas.width, pts[b].y * bioCanvas.height);
            });
            ctx.stroke();
            ctx.fillStyle = "#00FF41";
            [0, 5, 9, 13, 17].forEach(i => ctx.fillRect(pts[i].x * bioCanvas.width - 2, pts[i].y * bioCanvas.height - 2, 4, 4));
        }

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
    </script>
</body>
</html>
